name: Build and Deploy SEIMA Server to Azure Container Apps

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'docs/**'
  pull_request:
    branches:
      - main
    types: [closed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging

env:
  REGISTRY: docker.io
  IMAGE_NAME: seima-server
  JAVA_VERSION: '21'

jobs:
  # Security and Code Quality Check
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: 'Checkout code'
      uses: actions/checkout@v4

    - name: 'Run Trivy vulnerability scanner'
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: 'Upload Trivy scan results to GitHub Security tab'
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Build and Test
  build-test:
    runs-on: ubuntu-latest
    needs: security-scan
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
    - name: 'Checkout code'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 'Set up JDK ${{ env.JAVA_VERSION }}'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: 'Cache SonarCloud packages'
      uses: actions/cache@v3
      with:
        path: ~/.sonar/cache
        key: ${{ runner.os }}-sonar
        restore-keys: ${{ runner.os }}-sonar

    - name: 'Run Tests with Coverage'
      run: |
        mvn clean verify sonar:sonar \
          -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }} \
          -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
          -Dsonar.host.url=https://sonarcloud.io \
          -Dsonar.login=${{ secrets.SONAR_TOKEN }} \
          -Pcoverage

    - name: 'Build Application'
      run: mvn clean package -DskipTests -Pprod

    - name: 'Generate SBOM'
      uses: anchore/sbom-action@v0
      with:
        path: .
        format: spdx-json

    - name: 'Set up Docker Buildx'
      uses: docker/setup-buildx-action@v3

    - name: 'Login to Docker Hub'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: 'Extract metadata'
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: 'Build and Push Docker Image'
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        sbom: true
        provenance: true

    - name: 'Scan Docker Image'
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.meta.outputs.tags }}
        format: 'sarif'
        output: 'docker-trivy-results.sarif'

    - name: 'Upload Docker scan results'
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'docker-trivy-results.sarif'

  # Deploy to Production
  deploy-prod:
    runs-on: ubuntu-latest
    needs: build-test
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true))
    environment:
      name: production
      url: https://seima-server-prod.${{ secrets.AZURE_CONTAINER_ENV }}.azurecontainerapps.io
    
    steps:
    - name: 'Login to Azure'
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Get Current Deployment Info'
      id: current-deployment
      run: |
        CURRENT_IMAGE=$(az containerapp show \
          --name "seima-server-prod" \
          --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
          --query "properties.template.containers[0].image" -o tsv 2>/dev/null || echo "none")
        
        echo "current-image=${CURRENT_IMAGE}" >> $GITHUB_OUTPUT
        echo "Current image: ${CURRENT_IMAGE}"

    - name: 'Get MySQL Server Info'
      run: |
        MYSQL_FQDN=$(az mysql flexible-server show \
          --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
          --name "${{ secrets.MYSQL_SERVER_NAME }}" \
          --query "fullyQualifiedDomainName" -o tsv)
        
        echo "MYSQL_FQDN=${MYSQL_FQDN}" >> $GITHUB_ENV

    - name: 'Deploy to Azure Container Apps'
      id: deploy
      run: |
        IMAGE_TO_DEPLOY=$(echo "${{ needs.build-test.outputs.image-tag }}" | head -n1)
        echo "Deploying image: ${IMAGE_TO_DEPLOY}"
        
        az containerapp up \
          --name "seima-server-prod" \
          --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
          --environment "${{ secrets.AZURE_CONTAINER_ENV }}" \
          --image "${IMAGE_TO_DEPLOY}" \
          --target-port 8080 \
          --ingress external \
          --cpu 1.0 \
          --memory 2.0Gi \
          --min-replicas 2 \
          --max-replicas 5 \
          --scale-rule-name "http-requests" \
          --scale-rule-type "http" \
          --scale-rule-metadata "concurrentRequests=100" \
          --secrets \
            "mysql-password=${{ secrets.MYSQL_PASSWORD }}" \
            "jwt-secret=${{ secrets.JWT_SECRET }}" \
            "google-client-secret=${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            "mail-password=${{ secrets.MAIL_PASSWORD }}" \
            "redis-password=${{ secrets.REDIS_PASSWORD }}" \
          --env-vars \
            "SPRING_PROFILES_ACTIVE=prod" \
            "SPRING_DATASOURCE_URL=jdbc:mysql://${{ env.MYSQL_FQDN }}:3306/${{ secrets.MYSQL_DATABASE }}?useSSL=true&serverTimezone=Asia/Ho_Chi_Minh&allowPublicKeyRetrieval=true" \
            "SPRING_DATASOURCE_USERNAME=${{ secrets.MYSQL_USERNAME }}" \
            "SPRING_DATASOURCE_PASSWORD=secretref:mysql-password" \
            "SPRING_REDIS_HOST=${{ secrets.REDIS_HOST }}" \
            "SPRING_REDIS_PORT=${{ secrets.REDIS_PORT }}" \
            "SPRING_REDIS_PASSWORD=secretref:redis-password" \
            "JWT_SECRET=secretref:jwt-secret" \
            "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" \
            "GOOGLE_CLIENT_SECRET=secretref:google-client-secret" \
            "MAIL_HOST=${{ secrets.MAIL_HOST }}" \
            "MAIL_PORT=${{ secrets.MAIL_PORT }}" \
            "MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}" \
            "MAIL_PASSWORD=secretref:mail-password" \
            "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" \
            "PRODUCTION_FRONTEND_URL=${{ secrets.PRODUCTION_FRONTEND_URL }}" \
            "DEPLOYMENT_VERSION=${GITHUB_SHA:0:7}" \
            "DEPLOYMENT_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)"

    - name: 'Wait for Deployment Rollout'
      run: |
        echo "Waiting for deployment to stabilize..."
        for i in {1..20}; do
          READY_REPLICAS=$(az containerapp replica list \
            --name "seima-server-prod" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --query "length([?properties.runningState=='Running'])" -o tsv)
          
          if [ "$READY_REPLICAS" -ge "1" ]; then
            echo "‚úÖ Deployment stabilized with $READY_REPLICAS ready replicas"
            break
          fi
          
          echo "‚è≥ Waiting for replicas to be ready... ($i/20)"
          sleep 15
        done

    - name: 'Advanced Health Check'
      id: health-check
      run: |
        APP_URL=$(az containerapp show \
          --name "seima-server-prod" \
          --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
          --query "properties.configuration.ingress.fqdn" -o tsv)
        
        HEALTH_URL="https://${APP_URL}/actuator/health"
        READINESS_URL="https://${APP_URL}/actuator/health/readiness"
        LIVENESS_URL="https://${APP_URL}/actuator/health/liveness"
        
        echo "health-url=${HEALTH_URL}" >> $GITHUB_OUTPUT
        echo "app-url=https://${APP_URL}" >> $GITHUB_OUTPUT
        
        # Health check with retry and detailed logging
        for i in {1..24}; do
          echo "üîç Health check attempt $i/24..."
          
          # Check readiness
          if curl -f -s --max-time 10 "$READINESS_URL" > /dev/null; then
            echo "‚úÖ Readiness check passed"
            
            # Check liveness
            if curl -f -s --max-time 10 "$LIVENESS_URL" > /dev/null; then
              echo "‚úÖ Liveness check passed"
              
              # Check overall health with detailed response
              HEALTH_RESPONSE=$(curl -f -s --max-time 10 "$HEALTH_URL")
              echo "Health Response: $HEALTH_RESPONSE"
              
              if echo "$HEALTH_RESPONSE" | grep -q '"status":"UP"'; then
                echo "üéâ All health checks passed!"
                exit 0
              fi
            fi
          fi
          
          echo "‚è≥ Application not ready yet, waiting... (${i}0 seconds elapsed)"
          sleep 10
        done
        
        echo "‚ùå Health check failed after 4 minutes"
        exit 1

    - name: 'Performance Test'
      run: |
        APP_URL="${{ steps.health-check.outputs.app-url }}"
        
        # Simple load test
        echo "üöÄ Running performance test..."
        for i in {1..10}; do
          response_time=$(curl -o /dev/null -s -w "%{time_total}" "${APP_URL}/actuator/health")
          echo "Response time: ${response_time}s"
          
          if (( $(echo "$response_time > 5.0" | bc -l) )); then
            echo "‚ö†Ô∏è Warning: Response time ${response_time}s is high"
          fi
        done

    - name: 'Rollback on Failure'
      if: failure() && steps.current-deployment.outputs.current-image != 'none'
      run: |
        echo "üîÑ Rolling back to previous image: ${{ steps.current-deployment.outputs.current-image }}"
        
        az containerapp update \
          --name "seima-server-prod" \
          --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
          --image "${{ steps.current-deployment.outputs.current-image }}"
        
        echo "‚úÖ Rollback completed"

  # Cleanup and Notifications
  post-deploy:
    runs-on: ubuntu-latest
    needs: [build-test, deploy-prod]
    if: always()
    steps:
    - name: 'Cleanup old Docker images'
      run: |
        echo "üßπ Cleaning up old Docker images..."
        docker run --rm lumir/remove-dockerhub-tag \
          --user ${{ secrets.DOCKERHUB_USERNAME }} \
          --password ${{ secrets.DOCKERHUB_TOKEN }} \
          ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }} \
          --keep-last 10 || echo "Cleanup completed with warnings"

    - name: 'Send Slack Notification'
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          üöÄ *SEIMA Server Deployment*
          
          *Status:* ${{ needs.deploy-prod.result == 'success' && '‚úÖ SUCCESS' || '‚ùå FAILED' }}
          *Environment:* Production
          *Image:* `${{ needs.build-test.outputs.image-tag }}`
          *Commit:* `${{ github.sha }}`
          *Author:* ${{ github.actor }}
          *Branch:* ${{ github.ref_name }}
          
          ${{ needs.deploy-prod.result == 'success' && 'Application is healthy and running!' || 'Deployment failed - check logs for details' }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} 